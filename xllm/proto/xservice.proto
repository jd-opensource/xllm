syntax = "proto3";

package xllm_service.proto;
option cc_generic_services = true;

import "disagg_pd.proto";

message Empty {}

message Status {
  bool ok = 1;
}

message StatusCode {
  int32 status_code = 1;
}

enum InstanceType {
  DEFAULT = 0;
  PREFILL = 1;
  DECODE = 2;
}

message WorkerKVAddr {
  repeated uint64 layer_addrs = 1;
}

message InstanceMetaInfo {
  // http server address currently
  string name = 1;
  // rpc server address
  string rpc_address = 2;
  optional InstanceType type = 3;
  repeated uint64 cluster_ids = 4;
  repeated int64 k_cache_ids = 5;
  repeated int64 v_cache_ids = 6;
  int32 dp_size = 7;
  repeated string addrs = 8;
}

message KvCacheEvent {
    repeated bytes stored_cache = 1;
    repeated bytes removed_cache = 2;
    repeated bytes offload_cache = 3;
}

message LoadMetrics {
  uint64 waiting_requests_num = 1;
  float gpu_cache_usage_perc = 2;
}

message LatencyMetrics {
  int64 recent_max_ttft = 1;
  int64 recent_max_tbt = 2;
}

// TODO: add metainfo/metrics
message HeartbeatRequest {
  string name = 1;
  KvCacheEvent cache_event = 2;
  LoadMetrics load_metrics = 3;
  LatencyMetrics latency_metrics = 4;
}

message InstanceID {
  string name = 1;
}

message InstanceIDs {
  repeated string names = 1;
}

message ServiceConfig {
  bool enable_decode_response_to_service = 1;
}

service XllmRpcService {
  rpc RegisterInstance(InstanceMetaInfo) returns (StatusCode) {}
  rpc GetInstanceInfo(InstanceID) returns (InstanceMetaInfo) {}
  rpc Heartbeat(HeartbeatRequest) returns (Status) {}
  rpc GetStaticDecodeList(InstanceID) returns (InstanceIDs) {}
  rpc GetConfig(Empty) returns (ServiceConfig) {}
  // xllm service receive response from decode instance directly in disagg pd mode.
  // This can eliminate the cost brought by forwarding through prefill.
  rpc Generations(xllm.proto.DisaggStreamGenerations) returns (xllm.proto.StatusSet) {}
}

