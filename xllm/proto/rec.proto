syntax = "proto3";
option go_package = "jd.com/jd-infer/xllm;xllm";
package xllm.proto;
import "common.proto";

option cc_enable_arenas = true;
option cc_generic_services = true;
enum DataType {
    UNDEFINED = 0;
    // Basic types.
    FLOAT = 1;   // float
    UINT8 = 2;   // uint8_t
    INT8 = 3;    // int8_t
    UINT16 = 4;  // uint16_t
    INT16 = 5;   // int16_t
    INT32 = 6;   // int32_t
    INT64 = 7;   // int64_t
    STRING = 8;  // string
    BOOL = 9;    // bool
    // IEEE754 half-precision floating-point format (16 bits wide).
    // This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
    FLOAT16 = 10;
    DOUBLE = 11;
    UINT32 = 12;
    UINT64 = 13;
    COMPLEX64 = 14;     // complex with float32 real and imaginary components
    COMPLEX128 = 15;    // complex with float64 real and imaginary components
    // Non-IEEE floating-point format based on IEEE754 single-precision
    // floating-point number truncated to 16 bits.
    // This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
    BFLOAT16 = 16;
    // Non-IEEE floating-point format based on papers
    // FP8 Formats for Deep Learning, https://arxiv.org/abs/2209.05433,
    // 8-bit Numerical Formats For Deep Neural Networks, https://arxiv.org/pdf/2206.02915.pdf.
    // Operators supported FP8 are Cast, CastLike, QuantizeLinear, DequantizeLinear.
    // The computation usually happens inside a block quantize / dequantize
    // fused by the runtime.
    FLOAT8E4M3FN = 17;    // float 8, mostly used for coefficients, supports nan, not inf
    FLOAT8E4M3FNUZ = 18;  // float 8, mostly used for coefficients, supports nan, not inf, no negative zero
    FLOAT8E5M2 = 19;      // follows IEEE 754, supports nan, inf, mostly used for gradients
    FLOAT8E5M2FNUZ = 20;  // follows IEEE 754, supports nan, not inf, mostly used for gradients, no negative zero
    // 4-bit integer data types
    UINT4 = 21;  // Unsigned integer in range [0, 15]
    INT4 = 22;   // Signed integer in range [-8, 7], using two's-complement representation
    // 4-bit floating point data types
    FLOAT4E2M1 = 23;
    // E8M0 type used as the scale for microscaling (MX) formats:
    // https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf
    FLOAT8E8M0 = 24;
    // Future extensions go here.
}
// The data contained in a tensor represented by the repeated type
// that matches the tensor's data type. Protobuf oneof is not used
// because oneofs cannot contain repeated fields.
message InferTensorContents
{
    // Representation for BOOL data type. The size must match what is
    // expected by the tensor's shape. The contents must be the flattened,
    // one-dimensional, row-major order of the tensor elements.
    repeated bool bool_contents = 1;
    // Representation for INT8, INT16, and INT32 data types. The size
    // must match what is expected by the tensor's shape. The contents
    // must be the flattened, one-dimensional, row-major order of the
    // tensor elements.
    repeated int32 int_contents = 2;
    // Representation for INT64 data types. The size must match what
    // is expected by the tensor's shape. The contents must be the
    // flattened, one-dimensional, row-major order of the tensor elements.
    repeated int64 int64_contents = 3;
    // Representation for UINT8, UINT16, and UINT32 data types. The size
    // must match what is expected by the tensor's shape. The contents
    // must be the flattened, one-dimensional, row-major order of the
    // tensor elements.
    repeated uint32 uint_contents = 4;
    // Representation for UINT64 data types. The size must match what
    // is expected by the tensor's shape. The contents must be the
    // flattened, one-dimensional, row-major order of the tensor elements.
    repeated uint64 uint64_contents = 5;
    // Representation for FP32 data type. The size must match what is
    // expected by the tensor's shape. The contents must be the flattened,
    // one-dimensional, row-major order of the tensor elements.
    repeated float fp32_contents = 6;
    // Representation for FP64 data type. The size must match what is
    // expected by the tensor's shape. The contents must be the flattened,
    // one-dimensional, row-major order of the tensor elements.
    repeated double fp64_contents = 7;
    // Representation for BYTES data type. The size must match what is
    // expected by the tensor's shape. The contents must be the flattened,
    // one-dimensional, row-major order of the tensor elements.
    repeated bytes bytes_contents = 8;
}
// An input tensor for an inference request.
message InferInputTensor
{
    // The tensor name.
    string name = 1;
    // The tensor data type.
    DataType data_type = 2;
    // The tensor shape.
    repeated int64 shape = 3;
    // The tensor contents using a data-type format. This field must
    // not be specified if "raw" tensor contents are being used for
    // the inference request.
    InferTensorContents contents = 4;
}
// An output tensor returned for an inference request.
message InferOutputTensor
{
    // The tensor name.
    string name = 1;
    // The tensor data type.
    DataType datatype = 2;
    // The tensor shape.
    repeated int64 shape = 3;
    // The tensor contents using a data-type format. This field must
    // not be specified if "raw" tensor contents are being used for
    // the inference response.
    InferTensorContents contents = 4;
}